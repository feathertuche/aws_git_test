name: CI/CD for Kloo-Merge-integration-erp

on:
  push:
    branches:
      - main
      - dev
      - stage
      - master
      - demo

jobs:
  deployment-job:
    runs-on: ubuntu-latest

    steps:
      - name: Code Checkout
        uses: actions/checkout@v2

      - name: Set up Python 3.9
        uses: actions/setup-python@v2
        with:
          python-version: 3.9

      - name: Set up Git
        run: |
          git config --global user.name 'github-actions'
          git config --global user.email 'github-actions@github.com'

      - name: Fetch all tags
        run: git fetch --tags

      - name: Get latest tag
        id: get_latest_tag
        run: |
          latest_tag=$(git describe --tags $(git rev-list --tags --max-count=1) || echo "v1.0.0")
          echo "latest_tag=${latest_tag}"
          echo "::set-output name=latest_tag::${latest_tag}"

      - name: Get PR number from commit message
        id: get_pr_number
        run: |
          pr_number=$(cat $GITHUB_EVENT_PATH | grep -oE '\(#([0-9]+)\)' | sed 's/[()#]//g')
          echo "pr_number=${pr_number}"
          echo "::set-output name=pr_number::${pr_number}"

      - name: Fetch PR labels
        id: fetch_labels
        run: |
          pr_number="${{ steps.get_pr_number.outputs.pr_number }}"
          labels=$(curl -s -H "Authorization: token ${{ secrets.TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/issues/${pr_number}/labels" \
            | grep '"name"' | sed 's/.*: "\(.*\)".*/\1/' | paste -sd " " -)
          echo "labels=${labels}"
          echo "::set-output name=labels::${labels}"

      - name: Determine new version
        id: new_version
        run: |
          latest_tag="${{ steps.get_latest_tag.outputs.latest_tag }}"

          IFS='.' read -r -a version_parts <<< "${latest_tag#v}"
          major=${version_parts[0]}
          minor=${version_parts[1]}
          patch=${version_parts[2]}

          # Check if specific labels are present and increment accordingly
          labels="${{ steps.fetch_labels.outputs.labels }}"
          if [ -z "$labels" ]; then
            patch=$((patch + 1))
            new_label="patch"
          elif echo "$labels" | grep -q -i 'major'; then
            major=$((major + 1))
            minor=0
            patch=0
            new_label="major"
          elif echo "$labels" | grep -q -i 'minor'; then
            minor=$((minor + 1))
            patch=0
            new_label="minor"
          else
            patch=$((patch + 1))
            new_label="${labels%% *}"  # Take the first label as the new label
          fi

          new_tag="v$major.$minor.$patch-${new_label}"
          echo "new_tag=${new_tag}"
          echo "::set-output name=new_tag::${new_tag}"

      - name: Check if tag exists
        id: check_tag
        run: |
          tag_exists=$(git ls-remote --tags origin | grep "refs/tags/${{ steps.new_version.outputs.new_tag }}" || echo "false")
          echo "tag_exists=${tag_exists}"
          echo "::set-output name=tag_exists::${tag_exists}"
    
      - name: Create new tag
        if: steps.check_tag.outputs.tag_exists == 'false'
        run: |
          new_tag="${{ steps.new_version.outputs.new_tag }}"
          git tag ${new_tag}
          git push origin ${new_tag}

      - name: Output new tag
        if: steps.check_tag.outputs.tag_exists == 'false'
        run: |
          echo "New tag created: ${{ steps.new_version.outputs.new_tag }}"

      - name: Set branch check result
        id: branch_check
        run: |
          if [ "${GITHUB_REF}" = "refs/heads/main" ]; then
            echo "::set-output name=branch_check::true"
          else
            echo "::set-output name=branch_check::false"
          fi

      - name: Check labels
        id: label_check
        if: steps.branch_check.outputs.branch_check == 'true'
        run: |
          labels="${{ steps.fetch_labels.outputs.labels }}"
    
          if [ "${{ steps.check_tag.outputs.tag_exists }}" = "false" ] && 
            (echo "$labels" | grep -q -i 'major' ||
            echo "$labels" | grep -q -i 'minor' ||
            echo "$labels" | grep -q -i 'hotfix' ||
            [ -z "$labels" ]); then
            
            if [ -z "$labels" ]; then
              # No labels provided, treat it as 'minor'
              echo "::set-output name=labels_check::true"
              echo "::set-output name=labels_type::minor"
            else
              echo "::set-output name=labels_check::true"
              echo "::set-output name=labels_type::$(echo "$labels" | grep -o -i 'major\|minor\|hotfix' | head -n1)"
            fi
            
          else
            echo "::set-output name=labels_check::false"
          fi


      - name: Create GitHub Release
        if: steps.branch_check.outputs.branch_check == 'true' && steps.check_tag.outputs.tag_exists == 'false' 
        uses: actions/create-release@v1
        with:
          tag_name: ${{ steps.new_version.outputs.new_tag }}
          release_name: "Release ${{ steps.new_version.outputs.new_tag }}"
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.TOKEN }}

      - name: Login to AWS ECR
        run: |
          aws configure set aws_access_key_id ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws configure set aws_secret_access_key ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws configure set region ${{ vars.REGION }}
          aws ecr get-login-password --region ${{ vars.REGION }} | docker login --username AWS --password-stdin ${{ vars.DOCKER_REGISTRY }}

      - name: Dynamically setting ENV variables
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "env=prod" >> $GITHUB_ENV
            echo "secret_manager=kloo_environment_variable_prod" >> $GITHUB_ENV
            echo "db_password=Production_DB_Password" >> $GITHUB_ENV
            echo "app_secret_manager=prod_merge_integration" >> $GITHUB_ENV
            UPDATED_FUNC_NAME=$(echo "${{ vars.MERGE_INT_ERP_FUNC_NAME }}" | sed 's/env/prod/')
            echo "UPDATED_FUNC_NAME=$UPDATED_FUNC_NAME" >> $GITHUB_ENV
            echo "cluster_name=kloo-prod-cluster" >> $GITHUB_ENV
            echo "rds_host=mysql-kloo-prod.internal-service-kloo.com" >> $GITHUB_ENV
            echo "REQUEST_CLOUDWATCH_LOG_GROUP=erp-django-prod-request-log"  >> $GITHUB_ENV
            echo "API_CLOUDWATCH_LOG_GROUP=erp-django-prod-apilog"  >> $GITHUB_ENV
            echo "CLOUDWATCH_LOG_STREAM=erp-django-prod"  >> $GITHUB_ENV

          elif [[ "${{ github.ref }}" == "refs/heads/stage" ]]; then
            echo "env=stage" >> $GITHUB_ENV
            echo "secret_manager=kloo-Stage-Environment-Variables" >> $GITHUB_ENV
            echo "db_password=Stage_db_password" >> $GITHUB_ENV
            echo "app_secret_manager=stage_merge_integration" >> $GITHUB_ENV
            UPDATED_FUNC_NAME=$(echo "${{ vars.MERGE_INT_ERP_FUNC_NAME }}" | sed 's/env/stage/')
            echo "UPDATED_FUNC_NAME=$UPDATED_FUNC_NAME" >> $GITHUB_ENV
            echo "cluster_name=kloo-stage-cluster" >> $GITHUB_ENV
            echo "rds_host=mysql-kloo-stage.internal-service-kloo.com" >> $GITHUB_ENV
            echo "REQUEST_CLOUDWATCH_LOG_GROUP=erp-django-stage-request-log"  >> $GITHUB_ENV
            echo "API_CLOUDWATCH_LOG_GROUP=erp-django-stage-apilog"  >> $GITHUB_ENV
            echo "CLOUDWATCH_LOG_STREAM=erp-django-stage"  >> $GITHUB_ENV
          
          elif [[ "${{ github.ref }}" == "refs/heads/demo" ]]; then
            echo "env=demo" >> $GITHUB_ENV
            echo "secret_manager=kloo_environment_variables_demo" >> $GITHUB_ENV
            echo "db_password=kloo-demo-rds-creds" >> $GITHUB_ENV
            echo "app_secret_manager=non_prod_merge_integration" >> $GITHUB_ENV
            UPDATED_FUNC_NAME=$(echo "${{ vars.MERGE_INT_ERP_FUNC_NAME }}" | sed 's/-env//')
            echo "UPDATED_FUNC_NAME=$UPDATED_FUNC_NAME" >> $GITHUB_ENV
            echo "cluster_name=kloo-demo-cluster" >> $GITHUB_ENV
            QUEUE=$(echo "${{ vars.BULK_IMPORT_QUEUE }}" | sed 's/env/demo/')
            echo "UPDATED_QUEUE=$QUEUE" >> $GITHUB_ENV
            echo "REQUEST_CLOUDWATCH_LOG_GROUP=erp-django-demo-request-log"  >> $GITHUB_ENV
            echo "API_CLOUDWATCH_LOG_GROUP=erp-django-demo-apilog"  >> $GITHUB_ENV
            echo "CLOUDWATCH_LOG_STREAM=erp-django-demo"  >> $GITHUB_ENV

          else
            echo "env=dev" >> $GITHUB_ENV
            echo "secret_manager=kloo-dev-environment-variables" >> $GITHUB_ENV
            echo "db_password=Dev_DB_PASSWORD" >> $GITHUB_ENV
            echo "app_secret_manager=non_prod_merge_integration" >> $GITHUB_ENV
            UPDATED_FUNC_NAME=$(echo "${{ vars.MERGE_INT_ERP_FUNC_NAME }}" | sed 's/-env//')
            echo "UPDATED_FUNC_NAME=$UPDATED_FUNC_NAME" >> $GITHUB_ENV
            echo "cluster_name=kloo-dev-cluster" >> $GITHUB_ENV
            echo "rds_host=mysql-kloo-dev.internal-service-kloo.com" >> $GITHUB_ENV
            QUEUE=$(echo "${{ vars.BULK_IMPORT_QUEUE }}" | sed 's/env/dev/')
            echo "UPDATED_QUEUE=$QUEUE" >> $GITHUB_ENV
            echo "REQUEST_CLOUDWATCH_LOG_GROUP=erp-django-dev-request-log"  >> $GITHUB_ENV
            echo "API_CLOUDWATCH_LOG_GROUP=erp-django-dev-apilog"  >> $GITHUB_ENV
            echo "CLOUDWATCH_LOG_STREAM=erp-django-dev"  >> $GITHUB_ENV
          fi

      - name: Setting up AWS CLI
        run: |
          AWS_ACCESS_KEYID=$(aws secretsmanager get-secret-value --secret-id ${secret_manager} | jq --raw-output '.SecretString' | jq -r .\"AWS_ACCESS_KEYID\")
          echo "AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEYID" >> .env
          AWS_SECRET_ACCESSKEY=$(aws secretsmanager get-secret-value --secret-id ${secret_manager} | jq --raw-output '.SecretString' | jq -r .\"AWS_SECRET_ACCESSKEY\")
          echo "AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESSKEY" >> .env
          echo "AWS_DEFAULT_REGION=${{ vars.REGION }}" >> .env

      - name: DB Configure
        run: |
          cd ./merge_integration
          echo "DB_CONNECTION=mysql" >> .env
          echo "RDS_HOST=${rds_host}" >> .env
          echo "DB_PORT=3306" >> .env
          echo "DB_USER=masterkloo" >> .env
          echo "DB_NAME=myrdssql01" >> .env
          DB_PASSWORD=`aws secretsmanager get-secret-value --secret-id ${secret_manager} | jq --raw-output '.SecretString' | jq -r .${db_password}`
          echo "DB_PASSWORD=$DB_PASSWORD" >> .env
          echo "BULK_IMPORT_QUEUE=${UPDATED_QUEUE}" >> .env
      
      - name: DB configure for Demo
        run:
          cd ./merge_integration
          secret_json=$(aws secretsmanager get-secret-value --secret-id $db_password | jq -r '.SecretString')
    
          # Loop through each line of the secret
          while IFS= read -r line; do
            # Replace RDS_HOST with DB_HOST in the key before appending to .env
            modified_line=$(echo "$line" | sed 's/^RDS_HOST/DB_HOST/')
            # Append the modified line to the .env file
            echo "$modified_line" >> .env
          done <<< "$secret_json"
          
      - name: Creating Application variables
        run: |
          cd ./merge_integration
          secret_json=$(aws secretsmanager get-secret-value --secret-id ${app_secret_manager} | jq -r .'SecretString')
          while IFS= read -r line; do
            echo "$line" >> .env
          done <<< "$(echo "$secret_json" | jq -r 'to_entries | .[] | "\(.key)=\(.value)"')"
          echo "REQUEST_CLOUDWATCH_LOG_GROUP=${REQUEST_CLOUDWATCH_LOG_GROUP}"  >> .env
          echo "API_CLOUDWATCH_LOG_GROUP=${API_CLOUDWATCH_LOG_GROUP}"  >> .env
          echo "CLOUDWATCH_LOG_STREAM=${CLOUDWATCH_LOG_STREAM}"  >> .env
          cp .env ../.env


      - name: Building & pushing merge integration erp image
        run: |
          #----------------------------------------------------------------------------
          # Building images for merge integration erp
          #----------------------------------------------------------------------------
          docker build -t ${{ vars.DOCKER_REGISTRY }}/${env}/${{ vars.MERGE_INT_ERP_APP_NAME }}:latest -f MERGE_INT_ERP_DOCKERFILE .
          docker push ${{ vars.DOCKER_REGISTRY }}/${env}/${{ vars.MERGE_INT_ERP_APP_NAME }}:latest

          #Pushing the Cron image:
          docker build -t ${{ vars.DOCKER_REGISTRY }}/${env}/${{vars.MERGE_INT_ERP_APP_CRON_NAME}}:latest -f CRON_DOCKERFILE .
          docker push ${{ vars.DOCKER_REGISTRY }}/${env}/${{vars.MERGE_INT_ERP_APP_CRON_NAME}}:latest 

      - name: Deploying to non-prod environment
        if: ${{ env.env != 'prod' }}
        run: |
          aws ecs update-service --cluster ${cluster_name} --service ${UPDATED_FUNC_NAME} --force-new-deployment

      - name: Deploying to production
        if: ${{ env.env == 'prod' }}
        run: |

          aws configure set region ${{ vars.REGION }}
          AWS_ACCESS_KEYID=$(aws secretsmanager get-secret-value --secret-id kloo_environment_variable_prod | jq --raw-output '.SecretString' | jq -r .\"KLOO_PROD_AWS_ACCESS_KEYID\")
          echo "AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEYID" >> .env
          AWS_SECRET_ACCESSKEY=$(aws secretsmanager get-secret-value --secret-id kloo_environment_variable_prod | jq --raw-output '.SecretString' | jq -r .\"KLOO_PROD_AWS_SECRET_ACCESSKEY\")
          echo "AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESSKEY" >> .env
          echo "AWS_DEFAULT_REGION=${{ vars.REGION }}" >> .env

          aws codepipeline update-pipeline --cli-input-json file://codepipeline.json
          aws codepipeline start-pipeline-execution --name codepipeline-oauthapi
