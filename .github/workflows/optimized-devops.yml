name: CI/CD for Kloo-Merge-integration-erp

on:
  push:
    branches:
      - main
      - dev
      - stage

jobs:
  deployment-job:
    runs-on: ubuntu-latest

    steps:
      - name: Code Checkout
        uses: actions/checkout@v2

      - name: Set up Python 3.9
        uses: actions/setup-python@v2
        with:
          python-version: 3.9

      - name: Set up Git
        run: |
          git config --global user.name 'github-actions'
          git config --global user.email 'github-actions@github.com'

      - name: Fetch all tags
        run: git fetch --tags

      - name: Get latest tag
        id: get_latest_tag
        run: |
          latest_tag=$(git describe --tags $(git rev-list --tags --max-count=1) || echo "v1.0.0")
          echo "latest_tag=${latest_tag}"
          echo "::set-output name=latest_tag::${latest_tag}"

      - name: Get PR number from commit message
        id: get_pr_number
        run: |
          pr_number=$(cat $GITHUB_EVENT_PATH | grep -oE '\(#([0-9]+)\)' | sed 's/[()#]//g')
          echo "pr_number=${pr_number}"
          echo "::set-output name=pr_number::${pr_number}"

      - name: Fetch PR labels
        id: fetch_labels
        run: |
          pr_number="${{ steps.get_pr_number.outputs.pr_number }}"
          labels=$(curl -s -H "Authorization: token ${{ secrets.TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/issues/${pr_number}/labels" \
            | grep '"name"' | sed 's/.*: "\(.*\)".*/\1/' | paste -sd " " -)
          echo "labels=${labels}"
          echo "::set-output name=labels::${labels}"

      - name: Determine new version
        id: new_version
        run: |
          latest_tag="${{ steps.get_latest_tag.outputs.latest_tag }}"

          IFS='.' read -r -a version_parts <<< "${latest_tag#v}"
          major=${version_parts[0]}
          minor=${version_parts[1]}
          patch=${version_parts[2]}

          # Check if specific labels are present and increment accordingly
          labels="${{ steps.fetch_labels.outputs.labels }}"
          if [ -z "$labels" ]; then
            minor=$((minor + 1))
            patch=0
            new_label="minor"
          elif echo "$labels" | grep -q -i 'major'; then
            major=$((major + 1))
            minor=0
            patch=0
            new_label="major"
          elif echo "$labels" | grep -q -i 'minor'; then
            minor=$((minor + 1))
            patch=0
            new_label="minor"
          elif echo "$labels" | grep -q -i 'hotfix'; then
            patch=$((patch + 1))
            new_label="hotfix"
          else
            patch=$((patch + 1))
            new_label="${labels%% *}"  # Take the first label as the new label
          fi

          new_tag="v$major.$minor.$patch-${new_label}"
          echo "new_tag=${new_tag}"
          echo "::set-output name=new_tag::${new_tag}"

      - name: Check if tag exists
        id: check_tag
        run: |
          tag_exists=$(git ls-remote --tags origin | grep "refs/tags/${{ steps.new_version.outputs.new_tag }}" || echo "false")
          echo "tag_exists=${tag_exists}"
          echo "::set-output name=tag_exists::${tag_exists}"
    
      - name: Create new tag
        if: steps.check_tag.outputs.tag_exists == 'false'
        run: |
          new_tag="${{ steps.new_version.outputs.new_tag }}"
          git tag ${new_tag}
          git push origin ${new_tag}

      - name: Output new tag
        if: steps.check_tag.outputs.tag_exists == 'false'
        run: |
          echo "New tag created: ${{ steps.new_version.outputs.new_tag }}"

      - name: Set branch check result
        id: branch_check
        run: |
          if [ "${GITHUB_REF}" = "refs/heads/main" ]; then
            echo "::set-output name=branch_check::true"
          else
            echo "::set-output name=branch_check::false"
          fi

      - name: Check labels
        id: label_check
        if: steps.branch_check.outputs.branch_check == 'true'
        run: |
          labels="${{ steps.fetch_labels.outputs.labels }}"
    
          if [ "${{ steps.check_tag.outputs.tag_exists }}" = "false" ] && 
            (echo "$labels" | grep -q -i 'major' ||
            echo "$labels" | grep -q -i 'minor' ||
            echo "$labels" | grep -q -i 'hotfix' ||
            [ -z "$labels" ]); then
            
            if [ -z "$labels" ]; then
              # No labels provided, treat it as 'minor'
              echo "::set-output name=labels_check::true"
              echo "::set-output name=labels_type::minor"
            else
              echo "::set-output name=labels_check::true"
              echo "::set-output name=labels_type::$(echo "$labels" | grep -o -i 'major\|minor\|hotfix' | head -n1)"
            fi
            
          else
            echo "::set-output name=labels_check::false"
          fi

      - name: Create GitHub Release
        if: steps.branch_check.outputs.branch_check == 'true' && steps.check_tag.outputs.tag_exists == 'false'
        uses: actions/create-release@v1
        with:
          tag_name: ${{ steps.new_version.outputs.new_tag }}
          release_name: "Release ${{ steps.new_version.outputs.new_tag }}"
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.TOKEN }}

      - name: Login to AWS ECR
        run: |
          aws configure set aws_access_key_id ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws configure set aws_secret_access_key ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws configure set region ${{ vars.REGION }}
          aws ecr get-login-password --region ${{ vars.REGION }} | docker login --username AWS --password-stdin ${{ vars.DOCKER_REGISTRY }}

      - name: Dynamically setting ENV variables
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "env=prod" >> $GITHUB_ENV
            echo "secret_manager=kloo_environment_variable_prod" >> $GITHUB_ENV
            echo "db_password=Production_DB_Password" >> $GITHUB_ENV
            echo "app_secret_manager=prod_merge_integration" >> $GITHUB_ENV
            UPDATED_FUNC_NAME=$(echo "${{ vars.MERGE_INT_ERP_FUNC_NAME }}" | sed 's/env/prod/')
            echo "UPDATED_FUNC_NAME=$UPDATED_FUNC_NAME" >> $GITHUB_ENV
            echo "cluster_name=kloo-prod-cluster" >> $GITHUB_ENV
            echo "rds_host=mysql-kloo-prod.internal-service-kloo.com" >> $GITHUB_ENV

          elif [[ "${{ github.ref }}" == "refs/heads/stage" ]]; then
            echo "env=stage" >> $GITHUB_ENV
            echo "secret_manager=kloo-Stage-Environment-Variables" >> $GITHUB_ENV
            echo "db_password=Stage_db_password" >> $GITHUB_ENV
            echo "app_secret_manager=stage_merge_integration" >> $GITHUB_ENV
            UPDATED_FUNC_NAME=$(echo "${{ vars.MERGE_INT_ERP_FUNC_NAME }}" | sed 's/env/stage/')
            echo "UPDATED_FUNC_NAME=$UPDATED_FUNC_NAME" >> $GITHUB_ENV
            echo "cluster_name=kloo-stage-cluster" >> $GITHUB_ENV
            echo "rds_host=mysql-kloo-stage.internal-service-kloo.com" >> $GITHUB_ENV

          else
            echo "env=dev" >> $GITHUB_ENV
            echo "secret_manager=kloo-dev-environment-variables" >> $GITHUB_ENV
            echo "db_password=Dev_DB_PASSWORD" >> $GITHUB_ENV
            echo "app_secret_manager=non_prod_merge_integration" >> $GITHUB_ENV
            UPDATED_FUNC_NAME=$(echo "${{ vars.MERGE_INT_ERP_FUNC_NAME }}" | sed 's/-env//')
            echo "UPDATED_FUNC_NAME=$UPDATED_FUNC_NAME" >> $GITHUB_ENV
            echo "cluster_name=kloo-dev-cluster" >> $GITHUB_ENV
            echo "rds_host=mysql-kloo-dev.internal-service-kloo.com" >> $GITHUB_ENV
            QUEUE=$(echo "${{ vars.BULK_IMPORT_QUEUE }}" | sed 's/env/dev/')
            echo "UPDATED_QUEUE=$QUEUE" >> $GITHUB_ENV
          fi

      - name: Setting up AWS CLI
        run: |
          AWS_ACCESS_KEYID=$(aws secretsmanager get-secret-value --secret-id ${secret_manager} | jq --raw-output '.SecretString' | jq -r .\"AWS_ACCESS_KEYID\")
          echo "AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEYID" >> .env
          AWS_SECRET_ACCESSKEY=$(aws secretsmanager get-secret-value --secret-id ${secret_manager} | jq --raw-output '.SecretString' | jq -r .\"AWS_SECRET_ACCESSKEY\")
          echo "AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESSKEY" >> .env
          echo "env=$env" >> .env
          echo "db_password=$db_password" >> .env
          echo "app_secret_manager=$app_secret_manager" >> .env
          echo "rds_host=$rds_host" >> .env
          echo "cluster_name=$cluster_name" >> .env
          echo "REGION=${{ vars.REGION }}" >> .env
          echo "MERGE_INT_ERP_FUNC_NAME=$UPDATED_FUNC_NAME" >> .env
          echo "BULK_IMPORT_QUEUE=$UPDATED_QUEUE" >> .env

      - name: Set up and validate environment variables
        run: |
          echo "Env: $env"
          echo "DB password: $db_password"
          echo "App Secret Manager: $app_secret_manager"
          echo "Cluster Name: $cluster_name"
          echo "RDS Host: $rds_host"
          echo "AWS_REGION: ${{ vars.REGION }}"
          echo "Merge ERP Func Name: $UPDATED_FUNC_NAME"
          echo "Bulk Import Queue: $UPDATED_QUEUE"
          cat .env

      - name: Building & pushing merge integration erp image
        run: |
          #----------------------------------------------------------------------------
          # Building images for merge integration erp
          #----------------------------------------------------------------------------
          docker build -t ${{ vars.DOCKER_REGISTRY }}/${env}/${{ vars.MERGE_INT_ERP_APP_NAME }}:latest -f MERGE_INT_ERP_DOCKERFILE .
          docker push ${{ vars.DOCKER_REGISTRY }}/${env}/${{ vars.MERGE_INT_ERP_APP_NAME }}:latest

          #Pushing the Cron image:
          docker build -t ${{ vars.DOCKER_REGISTRY }}/${env}/${{vars.MERGE_INT_ERP_APP_CRON_NAME}}:latest -f CRON_DOCKERFILE .
          docker push ${{ vars.DOCKER_REGISTRY }}/${env}/${{vars.MERGE_INT_ERP_APP_CRON_NAME}}:latest 

      - name: Deploying to non-prod environment
        if: ${{ env.env != 'prod' }}
        run: |
          aws ecs update-service --cluster ${cluster_name} --service ${UPDATED_FUNC_NAME} --force-new-deployment

      - name: Deploying to production
        if: ${{ env.env == 'prod' }}
        run: |

          aws configure set region ${{ vars.REGION }}
          AWS_ACCESS_KEYID=$(aws secretsmanager get-secret-value --secret-id kloo_environment_variable_prod | jq --raw-output '.SecretString' | jq -r .\"KLOO_PROD_AWS_ACCESS_KEYID\")
          echo "AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEYID" >> .env
          AWS_SECRET_ACCESSKEY=$(aws secretsmanager get-secret-value --secret-id kloo_environment_variable_prod | jq --raw-output '.SecretString' | jq -r .\"KLOO_PROD_AWS_SECRET_ACCESSKEY\")
          echo "AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESSKEY" >> .env
          echo "AWS_DEFAULT_REGION=${{ vars.REGION }}" >> .env

          aws codepipeline update-pipeline --cli-input-json file://codepipeline.json
          aws codepipeline start-pipeline-execution --name codepipeline-oauthapi
